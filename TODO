Legend:
SPEC!!	- Not specified
SPEC	- Spec not finalized
	- Not done
	* Top priority
	. Partially done
	o Done
	X Abandoned

NEEDS TO BE WRITTEN

FOR 0.0.1: (The first alpha)
	[Requirements: hackers can use this system to try sending messages
         around.  At least one delivery method works.  The code may be
         DOS'able, but must not have remote exploits.  Dirservers need not
         work.  There need not be an interface for replies.  Key rotation
         need not be automated.]

	o Server
		o Unit tests for modulemanger built-in decoding and delivery.
	. Build
		- Marginal 'make install'
		- Marginal 'make dist'
	. Integration testing
		- Automated tests for several servers running on one machine.
		- Tests for servers on several different machines.
	. Refactor
		o Move exit types and addresses into Packet.py
		o Disable 'non-state-carrying' reply blocks.  Rename 'stateful'
		  (non-state-carrying) and 'stateless' (state-carrying) to
		  something less contradictory
		o Fix all {XXXX/FFFF/????}001 
		- Separate package for server code.
	. Final license
	        o Apply LGPL
		- Mark all files with note?
	- Documentation
		- Contributor's guide
		- Basic HOWTO
		- Difference between XXXX FFFF ????
		- Overall design
		- More readable mixminiond.conf
	- Patch specification:
	  	- SPEC comments from code
		- Incorporate e2e mixminion design
		- Rename stateful, stateless SURBs

Required for "1.0":
	 [These features must be in place before we can take the system out
          of alpha.  We'll do a series of point releases between 0.0.1 and
          the first beta.  The first three priorities are: replies,
  	  DOS-preventiion, and directories.]

	- Better CLIs
		- Actual strategy for reporting exceptions vs
	   	  user-visible errors.
	- Key rotation and expiry
		- Automatic keygen as needed
		- Automatic key rotation
		- Password-protected private identity keys
		- Password-protected private link/packet keys
	- Security
		- Make createPrivateDirs gripe about group-writable parent
		  dirs
		o Make hashlog code use journaling if underlying dbs are
		  unreliable.
	- Server core
		- Cleaner shutdown
		- Good reset handling
		- Drop undeliverable messages in a sane way
	- Modules and module support
		- MBOX
			- Use async or threading to cope with blocking MTAs
			- Full config validation
			- Full boilerplate text
		- Move boilerplate into outside files.  Add a generic
		  'Boilerplate' functionality.
		- Tell ModuleManager about async code
		- Real SMTP module
			- Abuse prevention
			- Exit filtering support
			- Support for setting 'Subject' and 'From' lines.
			- Support multiple exit addresses.
		- Incoming email gateway
		o Refactor module manager to do decoding _before_ passing
		  payloads to the individual module implementations.
		- Some notion of 'client modules' would be a good idea.
		- Put 'address' someplace more reasonable.
	- End-to-end issues
	        - K-of-N fragmentation and reassembly
		- Cap output size to prevent zlib bombing
	- Configurablity
	  	- Support for one-side-only MMTP configurations.
		- Make batching algorithm configurable
		o Infer server IP
		. Freak out properly on missing/unpublishable IP.
		- Make listening configurable for multiple ports/ips, not
		  all of which need be published.  Perhaps allow different
		  rules for each listener.
		- Full validation function for client
		- Full validation function for server
		- Make 'push' and 'retry' delivery rates independant and
		  module-adjustable
		- Make 'drop undeliverable' rate configurable.
		- Implement allow/deny code
		- Make server gripe loudly when config doesn't match published
		  serverinfo.
	- Client support
	  	- Generate (but don't send) a message
		- Generate a reply block
		- Read message from reply block
		- Path selection
		        - Automatic path selection
			. Understand differing server features
			- Watch out for servers that are really the
			  same server
			- Notice servers that don't support MMTP, or
			  don't relay.
			- Notice Allow/Deny.
		- Reply to reply block
		- Examine reply block
		- Send message to user with known key
		. Send message to user with known server
		- Real server directory management
		- Real PKI
	        - Queue a bunch of messages at the client level.
		- Client-side pooling
	- MMTP / async
		- Make listen options configurable (backlog, IP)
		- Code to send junk (connection padding)
SPEC!!		- Timeout old connections
		- Renegotiate connections
		- (Make sure sender retries on bogus close)
		- Session managment and resumption (security issues?)
		- Tests for all cases:
			- Junk
			- Multiple senders
			- Bad senders
			- Bad recipients
			- Hunt down leaks
	- Build and install process
		- Use sane arguments when testing with multiple python versions
		. Get SSL as needed
		- Well-tested 'make install'
		- RPMS, debs, and so on
		- Make sure we run on solaris and *BSD.
		- "Somebody" should do a Windows port of the client code
	- Protocol support
		- External reply block format
		o End-to-end payload encryption
		. Reading messages sent to reply blocks
		. Correct implementation of stateless reply blocks
SPEC		o Patch to address George's 15August attack
	- Testing
		- Test on other (non-redhat, non-linux) systems
		- Repeatable CLI tests.
		        - For client
			- For server
	- Directories
		- ServerInfo: complete validation rules
		- Implementation for directory servers
		- Publishing to directory servers
			- Support
			- Automation
		- Downloading from directory servers
			- Support
			- Automation
	- Full documentation
		- Complete docs for all code, with comments and examples.
		- Write guide for module developers
		- Write complete user's manual
		- Complete all other docs

Unspecified:
	[We don't have any specification for this functionality, or any
	 mandate to include it in 1.0.  If it's specified before 1.0 is
	 done, however, it should go in.]

	- Generate link padding
	- Generate dummy messages
	- IPv6 support.

WHEN WE GET THE CHANCE:
	[This stuff could be for any version 1.0 or later; it's not a
 	 requirement for 1.0.]
	- License-friendliness:
		- Switch from OpenSSL to NSS or GNUTLS
	- GUI
	- Multithreaded design to scale to multiple CPUs
	- Security
		- Memlockall wrapper
		- Generic secure delete
		- Support for loopback fs automation and shredding.
	- Portability
		- Server running on windows.
	- Time the rest of the system
	- Make DB module choice configurable?

NEED TO BE TESTED
- Signals

NEED TO BE DOCUMENTED

NEEDS TO BE BENCHMARKED
- TLS for leaks
- PEM for leaks
- gen_dh for leaks
- gen_cert for leaks

-----------
(for emacs)
  Local Variables:
  mode:text
  End:
